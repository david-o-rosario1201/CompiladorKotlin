@page "/"
@using System.Text.RegularExpressions
@using CompiladorKotlin.Clases
@rendermode InteractiveServer

<PageTitle>Compilador Kotlin</PageTitle>

<div class="container">
	<div class="card shadow-lg">
		<div class="card-header">
			<div class="d-flex justify-content-center">
				<img src="Imagenes/Kotlin_logo.svg.png" alt="Kotlin" style="width: 150px; height: auto;" />
			</div>
		</div>
		<div class="card-body">
			<div class="row mb-3">
				<div class="col-6">
					@*Escribir*@
					<label class="form-label" for="escribir"><strong>Escribir</strong></label>
					<InputTextArea id="escribir" class="form-control" @bind-Value="escribir"></InputTextArea>
				</div>
				<div class="col-6">
					@*Mostrar*@
					<label class="form-label" for="mostrar"><strong>Mostrar</strong></label>
					<InputTextArea id="mostrar" class="form-control" @bind-Value="mostrar"></InputTextArea>
				</div>
			</div>
		</div>
		<div class="card-footer d-flex justify-content-center">
			<button type="button" class="btn btn-outline-primary" @onclick="Compilar">Compilar</button>
		</div>
	</div>
</div>

@code{
	public string escribir { get; set; }
	public string valor { get; set; }
	public string mostrar { get; set; }
	public string valorEntreParentesis { get; set; }


	////Patrones
	///Patrones para imprimir
	//string patronPrint = @"^print\(""[^""]*""\)";
	//string patronPrint = @"^print\(((""[^""]*"")|(\d+(\.\d+)?))\)$";
	string patronPrint = @"^print\(((""[^""]*"")|(\d+(\.\d+)?))\)";
	string patronPrintConVariable = @"^print\([A-Za-z0-9]+\)";

	string patronPrintln = @"^println\(""[^""]*""\)";
	string patronPrintlnConVariable = @"^println\([A-Za-z0-9]+\)";

	//Comentario
	string patronComentario = @"^//";

	//Enteros
	string patronEnteroValConValor = @"^val _?[A-Za-z0-9]*: Int = [0-9]+";
	string patronEnteroVal = @"^val _?[A-Za-z0-9]*: Int";

	string patronEnteroVarConValor = @"^var _?[A-Za-z0-9]*: Int = [0-9]+";
	string patronEnteroVar = @"^var _?[A-Za-z0-9]*: Int";

	//Short
	string patronShortValConValor = @"^val _?[A-Za-z0-9]*: Short = [0-9]+";
	string patronShortVal = @"^val _?[A-Za-z0-9]*: Short";

	string patronShortVarConValor = @"^var _?[A-Za-z0-9]*: Short = [0-9]+";
	string patronShortVar = @"^var _?[A-Za-z0-9]*: Short";

	//Long
	string patronLongValConValor = @"^val _?[A-Za-z0-9]*: Long = [0-9]+";
	string patronLongVal = @"^val _?[A-Za-z0-9]*: Long";

	string patronLongVarConValor = @"^var _?[A-Za-z0-9]*: Long = [0-9]+";
	string patronLongVar = @"^var _?[A-Za-z0-9]*: Long";

	//Float
	string patronFloatValConValor = @"^val _?[A-Za-z0-9]*: Float = [0-9]+";
	string patronFloatVal = @"^val _?[A-Za-z0-9]*: Float";

	string patronFloatVarConValor = @"^var _?[A-Za-z0-9]*: Float = [0-9]+";
	string patronFloatVar = @"^var _?[A-Za-z0-9]*: Float";

	//Double
	string patronDoubleValConValor = @"^val _?[A-Za-z0-9]*: Double = [0-9]+";
	string patronDoubleVal = @"^val _?[A-Za-z0-9]*: Double";

	string patronDoubleVarConValor = @"^var _?[A-Za-z0-9]*: Double = [0-9]+";
	string patronDoubleVar = @"^var _?[A-Za-z0-9]*: Double";

	//Boolean
	string patronBooleanValConValor = @"^val _?[A-Za-z0-9]*: Boolean = [true false]+";///debo arreglar que no se escriba true true
	string patronBooleanVal = @"^val _?[A-Za-z0-9]*: Boolean";

	string patronBooleanVarConValor = @"^var _?[A-Za-z0-9]*: Boolean = [true false]+";
	string patronBooleanVar = @"^var _?[A-Za-z0-9]*: Boolean";

	//Char
	string patronCharValConValor = @"^val _?[A-Za-z0-9]*: Char = '\w'";
	string patronCharVal = @"^val _?[A-Za-z0-9]*: Char";

	string patronCharVarConValor = @"^var _?[A-Za-z0-9]*: Char = '\w'";
	string patronCharVar = @"^var _?[A-Za-z0-9]*: Char";

	//String
	string patronStringValConValor = @"^val _?[A-Za-z0-9]*: String = ""[^""]*""";
	string patronStringVal = @"^val _?[A-Za-z0-9]*: String";

	string patronStringVarConValor = @"^var _?[A-Za-z0-9]*: String = ""[^""]*""";
	string patronStringVar = @"^var _?[A-Za-z0-9]*: String";


	//Clases
	Entero entero;
	Short mishort;
	Long milong;
	Float mifloat;
	miDouble midouble;
	miBoolean boolean;
	miChar michar;
	Cadena cadena;


	//Lista
	List<Entero> enteroList;
	List<Short> shortList;
	List<Long> longList;
	List<Float> floatList;
	List<miDouble> doubleList;
	List<miBoolean> booleanList;
	List<miChar> charList;
	List<Cadena> cadenaList;


	//Variables para comparaciones
	int varEntero1 = 0;
	int varEntero2 = 0;


	//Dicioanrio de variables
	Dictionary<string, bool> variables = new Dictionary<string, bool>();

	//Varible bool para ver si hay errores
	bool sinErrores = true;

	//patron para igualar
	string patronAsignacion = @"^_?[A-Za-z0-9]* = _?[A-Za-z0-9]*";

	//patron para realizar operaciones aritmeticas
	//string patronSumar = @"_?[A-Za-z0-9]* = \d+(\.\d+)? \+ \d+(\.\d+)?";
	string patronSumar = @"_?[A-Za-z0-9]* = (_?[A-Za-z0-9]*|\d+(\.\d+)?) \+ (_?[A-Za-z0-9]*|\d+(\.\d+)?)";
	string patronRestar = @"_?[A-Za-z0-9]* = (_?[A-Za-z0-9]*|\d+(\.\d+)?) \- (_?[A-Za-z0-9]*|\d+(\.\d+)?)";
	string patronMulti = @"_?[A-Za-z0-9]* = (_?[A-Za-z0-9]*|\d+(\.\d+)?) \* (_?[A-Za-z0-9]*|\d+(\.\d+)?)";
	string patronDivi = @"_?[A-Za-z0-9]* = (_?[A-Za-z0-9]*|\d+(\.\d+)?) \/ (_?[A-Za-z0-9]*|\d+(\.\d+)?)";

	//patron de condicion
	string patronCondicion = @"if\s*\(_?[A-Za-z0-9]+\s*(==|!=|>|>=|<|<=)\s*_?[A-Za-z0-9]+\s*\)";
	//else
	string patronElse = @"else";

	//patron ciclo for
	string patronCicloFor = @"for\(int _?[A-Za-z0-9]* = (_?[A-Za-z0-9]*|\d+(\.\d+)?); 
		_?[A-Za-z0-9]* (==|!=|<|<=|>|>=) (_?[A-Za-z0-9]*|\d+(\.\d+)?); _?[A-Za-z0-9]*\+\+?\)";

	//patron ciclo while
	string patronCicloWhile = @"while\s*\(\s*\w+\s*(==|!=|<|<=|>|>=)\s*\w+\s*\)";

	//patron contador
	string patronContador = @"_?[A-Za-z0-9]+\s*(\+\+|--)";


	async Task Compilar()
	{
		//Inicializar
		enteroList = new List<Entero>();
		shortList = new List<Short>();
		longList = new List<Long>();
		floatList = new List<Float>();
		doubleList = new List<miDouble>();
		booleanList = new List<miBoolean>();
		charList = new List<miChar>();
		cadenaList = new List<Cadena>();
		variables = new Dictionary<string, bool>();
		mostrar = string.Empty;
		valor = escribir;
		//
		sinErrores = true;

		Imprimir("Compilando...\n");
		await Task.Delay(1000);

		if(String.IsNullOrEmpty(valor))
		{
			Imprimir("\n*Se esperaba \"fun main() {}\" \n\n----------------------------------------------------------"
			+ "-----------------------------------------------------\nCompilación con errores:(!!!!!");
		}
		else
			Verificar();

		//revisar mas adelante la condicion de imprimir una variable (reload)
		//El problema esta cuando intento crear e inicializar las variables
	}

	void Verificar()
	{
		if (valor.StartsWith("fun main() {") && valor.EndsWith("}"))
		{
			valor = borrarCadena("fun main() {");
			valor = valor.Remove(valor.Length - 1, 1);

			string borrarLinea;

			while (valor.Length > 1)
			{
				//Comentario
				if(Regex.IsMatch(valor,patronComentario))
				{
					int indiceSaltoLinea = valor.IndexOf('\n');
					var borrarComentario = valor.Substring(0,indiceSaltoLinea);
					valor = borrarCadena(borrarComentario);
				}

				//Imprimir
				else if (Regex.IsMatch(valor, patronPrint) || Regex.IsMatch(valor, patronPrintln)
					|| Regex.IsMatch(valor, patronPrintConVariable)
						|| Regex.IsMatch(valor, patronPrintlnConVariable))
				{
					if (VerificarImprimir()) break;
				}

				//Declaracion de variables
				else if (valor.StartsWith("var ") || valor.StartsWith("val "))
				{
					if (VerificarCreacionVariables()) break;
				}

				//Sumar
				else if (Regex.IsMatch(valor, patronSumar))
				{
					if (VerificarSuma()) break;
				}

				//Restar
				else if (Regex.IsMatch(valor, patronRestar))
				{
					if (VerificarResta()) break;
				}

				//Multiplicar
				else if (Regex.IsMatch(valor, patronMulti))
				{
					if (VerificarMultiplicacion()) break;
				}

				//Dividir
				else if (Regex.IsMatch(valor, patronDivi))
				{
					if (VerificarDivision()) break;
				}

				//Asignar Variable
				else if (Regex.IsMatch(valor, patronAsignacion))
				{
					if (AsignarValorVariable()) break;
				}

				//Ciclo While
				else if (Regex.IsMatch(valor, patronCicloWhile))
				{
					CicloWhile();
				}

				//Condicion
				else if(Regex.IsMatch(valor,patronCondicion))
				{
					if (VerificarCondicion()) break;
				}

				//Ciclo For
				else if(Regex.IsMatch(valor,patronCicloFor))
				{
					//CicloWhile();
				}

				else
				{
					sinErrores = false;
					Imprimir($"\n*No se reconoce  \"{valor}\"");
					break;
				}
			}
		}
		else
		{
			sinErrores = false;
			Imprimir("\n*Se esperaba 'fun main() {}'");
		}

		if (sinErrores)
			Imprimir("\n---------------------------------------------------------------------------------------------------------------\nCompilación completa sin errores:)!!!!!");
		else
			Imprimir("\n---------------------------------------------------------------------------------------------------------------\nCompilación con errores:(!!!!!");
	}


	//Verificar Imprimir
	bool VerificarImprimir()
	{
		int indiceP = valor.IndexOf('p');
		int indiceParentesis = valor.IndexOf(')');

		//tomo la linea
		var borrarLinea = valor.Substring(indiceP, indiceParentesis + 1);

		if (Regex.IsMatch(valor, patronPrint) || Regex.IsMatch(valor, patronPrintln))
		{
			//tomo los valores entre parentesis
			int indiceComillasInicio = borrarLinea.IndexOf('"');
			int indiceComillasFin = borrarLinea.LastIndexOf('"');

			if (indiceComillasInicio != -1 && indiceComillasFin != 1)
			{
				valorEntreParentesis = valor
				.Substring(indiceComillasInicio + 1, indiceComillasFin - indiceComillasInicio - 1);
			}
			else
			{
				int indiceParentesisInicio = borrarLinea.IndexOf('(');
				int indiceParentesisFin = borrarLinea.IndexOf(')');

				valorEntreParentesis = valor
					.Substring(indiceParentesisInicio + 1, indiceParentesisFin - indiceParentesisInicio - 1);
			}

			if (Regex.IsMatch(borrarLinea, patronPrint))
				Imprimir("\n" + valorEntreParentesis);
			else
				Imprimir("\n\n" + valorEntreParentesis);

			valor = borrarCadena(borrarLinea);
		}

		else if (Regex.IsMatch(valor, patronPrintConVariable)
			|| Regex.IsMatch(valor, patronPrintlnConVariable))
		{
			int indiceParentesisInicio = valor.IndexOf('(');
			int indiceParentesisFin = valor.IndexOf(')');

			string valorEntreParentesis = valor
				.Substring(indiceParentesisInicio + 1, indiceParentesisFin - indiceParentesisInicio - 1);

			if (VerificarQueNoSeaUnaPalabraReservada(valorEntreParentesis) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == valorEntreParentesis);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var booleanResult = booleanList.FirstOrDefault(v => v.nombre == result.Key);
					var charResult = charList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					if (enteroResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + enteroResult.valor.ToString());
						else
							Imprimir("\n\n" + enteroResult.valor.ToString());
					}

					else if (shortResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + shortResult.valor.ToString());
						else
							Imprimir("\n\n" + shortResult.valor.ToString());
					}

					else if (longResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + longResult.valor.ToString());
						else
							Imprimir("\n\n" + longResult.valor.ToString());
					}

					else if (floatResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + longResult.valor.ToString());
						else
							Imprimir("\n\n" + longResult.valor.ToString());
					}

					else if (doubleResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + doubleResult.valor.ToString());
						else
							Imprimir("\n\n" + doubleResult.valor.ToString());
					}

					else if (booleanResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + booleanResult.valor.ToString());
						else
							Imprimir("\n\n" + booleanResult.valor.ToString());
					}

					else if (charResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + charResult.valor.ToString());
						else
							Imprimir("\n\n" + charResult.valor.ToString());
					}

					else if (cadenaResult is not null)
					{
						if (Regex.IsMatch(borrarLinea, patronPrintConVariable))
							Imprimir("\n" + cadenaResult.valor.ToString());
						else
							Imprimir("\n" + cadenaResult.valor.ToString());
					}

					valor = borrarCadena(borrarLinea);
				}
				else
				{
					if (Regex.IsMatch(valorEntreParentesis, @"\d"))
					{
						if (borrarLinea.StartsWith("println"))
							Imprimir("\n\n" + valorEntreParentesis.ToString());
						else
							Imprimir("\n" + valorEntreParentesis.ToString());

						valor = borrarCadena(borrarLinea);
					}
					else
					{
						sinErrores = false;
						Imprimir($"\n*No se recoce \"{valorEntreParentesis}\"");
						return true;
					}
				}
			}
			else
				return true;
		}
		return false;
	}

	//Verificar Creacion de variables

	bool VerificarCreacionVariables()
	{
		int inicioNombre = valor.IndexOf(' ');
		int finNombre = valor.IndexOf(':');
		string nombre = valor.Substring(inicioNombre + 1, finNombre - inicioNombre - 1).Trim();

		int indiceV = valor.IndexOf('v');
		int saltoLinea = valor.IndexOf('\n');

		//borrarLinea
		string borrarLinea;

		if (variableExiste(nombre))
		{
			Imprimir($"\nYa existe una variable con este nombre '{nombre}'");
			sinErrores = false;
			return true;
		}
		else
		{
			//Entero
			if (Regex.IsMatch(valor, patronEnteroVarConValor)
				|| Regex.IsMatch(valor, patronEnteroValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim(); // Obtén la parte de la cadena después del signo '='

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					entero = new Entero(nombre, int.Parse(valorDespuesDelIgual));
					enteroList.Add(entero);
					variables.Add(entero.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronEnteroVar)
				|| Regex.IsMatch(valor, patronEnteroVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					entero = new Entero(nombre);
					enteroList.Add(entero);
					variables.Add(entero.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Short
			else if (Regex.IsMatch(valor, patronShortVarConValor)
				|| Regex.IsMatch(valor, patronShortValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim(); // Obtén la parte de la cadena después del signo '='

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					mishort = new Short(nombre, short.Parse(valorDespuesDelIgual));
					shortList.Add(mishort);
					variables.Add(mishort.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronShortVar)
				|| Regex.IsMatch(valor, patronShortVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					mishort = new Short(nombre);
					shortList.Add(mishort);
					variables.Add(mishort.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Long
			else if (Regex.IsMatch(valor, patronLongVarConValor)
				|| Regex.IsMatch(valor, patronLongValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim(); // Obtén la parte de la cadena después del signo '='

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					milong = new Long(nombre, long.Parse(valorDespuesDelIgual));
					longList.Add(milong);
					variables.Add(milong.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronLongVar)
				|| Regex.IsMatch(valor, patronLongVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					milong = new Long(nombre);
					longList.Add(milong);
					variables.Add(milong.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Float
			else if (Regex.IsMatch(valor, patronFloatVarConValor)
				|| Regex.IsMatch(valor, patronFloatValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim(); // Obtén la parte de la cadena después del signo '='

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					mifloat = new Float(nombre, float.Parse(valorDespuesDelIgual));
					floatList.Add(mifloat);
					variables.Add(mifloat.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronFloatVar)
				|| Regex.IsMatch(valor, patronFloatVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					mifloat = new Float(nombre);
					floatList.Add(mifloat);
					variables.Add(mifloat.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Double
			else if (Regex.IsMatch(valor, patronDoubleVarConValor)
				|| Regex.IsMatch(valor, patronDoubleValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim(); // Obtén la parte de la cadena después del signo '='

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					midouble = new miDouble(nombre, double.Parse(valorDespuesDelIgual));
					doubleList.Add(midouble);
					variables.Add(midouble.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronDoubleVar)
				|| Regex.IsMatch(valor, patronDoubleVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					midouble = new miDouble(nombre);
					doubleList.Add(midouble);
					variables.Add(midouble.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Boolean
			else if (Regex.IsMatch(valor, patronBooleanVarConValor)
				|| Regex.IsMatch(valor, patronBooleanValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim(); // Obtén la parte de la cadena después del signo '='

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					boolean = new miBoolean(nombre, bool.Parse(valorDespuesDelIgual));
					booleanList.Add(boolean);
					variables.Add(boolean.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronBooleanVar)
				|| Regex.IsMatch(valor, patronBooleanVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					boolean = new miBoolean(nombre);
					booleanList.Add(boolean);
					variables.Add(boolean.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Char
			else if (Regex.IsMatch(valor, patronCharVarConValor)
				|| Regex.IsMatch(valor, patronCharValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				// Encuentra el índice del signo '='
				int indiceIgual = borrarLinea.IndexOf('=');

				// Encuentra el índice de las comillas simples que rodean el carácter
				int inicioChar = borrarLinea.IndexOf('\'', indiceIgual);
				int finChar = borrarLinea.IndexOf('\'', inicioChar + 1);

				// Extrae el carácter entre las comillas simples
				char charValor = borrarLinea.Substring(inicioChar + 1, finChar - inicioChar - 1)[0];

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					michar = new miChar(nombre, charValor);
					charList.Add(michar);
					variables.Add(michar.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronCharVar)
				|| Regex.IsMatch(valor, patronCharVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					michar = new miChar(nombre);
					charList.Add(michar);
					variables.Add(michar.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}

			//Cadena
			else if (Regex.IsMatch(valor, patronStringVarConValor)
				|| Regex.IsMatch(valor, patronStringValConValor))
			{
				//tratar de poner esto en una funcion
				borrarLinea = valor.Substring(indiceV, saltoLinea + 1);
				valor = borrarCadena(borrarLinea);

				// Encuentra el índice del signo '='
				int indiceIgual = borrarLinea.IndexOf('=');

				// Obtén la parte de la cadena después del signo '='
				string valorDespuesDelIgual = borrarLinea.Substring(indiceIgual + 1).Trim();

				// Elimina las comillas dobles alrededor del valor
				valorDespuesDelIgual = valorDespuesDelIgual.Trim('"', ' ');

				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					cadena = new Cadena(nombre, valorDespuesDelIgual);
					cadenaList.Add(cadena);
					variables.Add(cadena.nombre, true);
				}
				else
					return true;
			}

			else if (Regex.IsMatch(valor, patronStringVar)
				|| Regex.IsMatch(valor, patronStringVal))
			{
				if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
				{
					cadena = new Cadena(nombre);
					cadenaList.Add(cadena);
					variables.Add(cadena.nombre, true);

					borrarLinea = valor.Substring(indiceV, saltoLinea + 2);
					valor = borrarCadena(borrarLinea);
				}
				else
					return true;
			}
		}
		return false;
	}

	//Verificar Suma
	bool VerificarSuma()
	{
		int saltoLinea = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, saltoLinea + 2);
		valor = borrarCadena(borrarLinea);

		if (Sumar(borrarLinea))
		{
			sinErrores = true;
			return true;
		}
		return false;
	}

	//Verificar Resta
	bool VerificarResta()
	{
		int saltoLinea = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, saltoLinea + 2);
		valor = borrarCadena(borrarLinea);

		if (Restar(borrarLinea))
		{
			sinErrores = true;
			return true;
		}
		return false;
	}

	//Verificar Multiplicacion
	bool VerificarMultiplicacion()
	{
		int saltoLinea = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, saltoLinea + 2);
		valor = borrarCadena(borrarLinea);

		if (Restar(borrarLinea))
		{
			sinErrores = true;
			return true;
		}
		return false;
	}

	//Verificar Division
	bool VerificarDivision()
	{
		int saltoLinea = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, saltoLinea + 2);
		valor = borrarCadena(borrarLinea);

		if (Restar(borrarLinea))
		{
			sinErrores = true;
			return true;
		}
		return false;
	}

	//AsignarValorVariable
	bool AsignarValorVariable()
	{
		int saltoLinea = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, saltoLinea);
		valor = borrarCadena(borrarLinea);

		int indiceIgual = borrarLinea.IndexOf('='); // Encuentra la posición del signo '='
		string variable1 = borrarLinea.Substring(0, indiceIgual).Trim();
		string variable2 = borrarLinea.Substring(indiceIgual + 1).Trim();

		if (VerificarQueNoSeaUnaPalabraReservada(variable1) == false
			|| VerificarQueNoSeaUnaPalabraReservada(variable2) == false)
		{
			var result = variables.FirstOrDefault(v => v.Key == variable1);
			if (result.Key != null)
			{
				var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
				var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
				var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
				var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
				var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
				var booleanResult = booleanList.FirstOrDefault(v => v.nombre == result.Key);
				var charResult = charList.FirstOrDefault(v => v.nombre == result.Key);
				var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

				var result2 = variables.FirstOrDefault(v => v.Key == variable2);

				if (result2.Key == null)
				{
					if (enteroResult is not null && int.TryParse(variable2, out int datoEntero))
						enteroResult.valor = datoEntero;

					else if (shortResult is not null && short.TryParse(variable2, out short datoShort))
						shortResult.valor = datoShort;

					else if (longResult is not null && long.TryParse(variable2, out long datoLong))
						longResult.valor = datoLong;

					else if (floatResult is not null && float.TryParse(variable2, out float datoFloat))
						floatResult.valor = datoFloat;

					else if (doubleResult is not null && double.TryParse(variable2, out double datoDouble))
						doubleResult.valor = datoDouble;

					else if (booleanResult is not null && bool.TryParse(variable2, out bool datoBoolean))
						booleanResult.valor = datoBoolean;

					else if (charResult is not null)
					{
						// Si es un char, asegúrate de que el valor tenga comillas simples
						if (variable2.Length != 3 || variable2[0] != '\'' || variable2[2] != '\'')
						{
							Imprimir($"\nSe esperaban comillas simples para el tipo de dato char en la variable '{variable1}'");
							sinErrores = false;
							return true;
						}
						charResult.valor = variable2[1]; // Asigna el valor entre las comillas simples
					}
					else if (cadenaResult is not null)
					{
						// Si es un string, asegúrate de que el valor tenga comillas dobles
						if (variable2.Length < 2 || variable2[0] != '"' || variable2[variable2.Length - 1] != '"')
						{
							Imprimir($"\nSe esperaban comillas dobles para el tipo de dato string en la variable '{variable1}'");
							sinErrores = false;
							return true;
						}
						cadenaResult.valor = variable2.Substring(1, variable2.Length - 2); // Asigna el valor entre las comillas dobles
					}

					else
					{
						Imprimir($"\nLos tipos de datos '{variable1}' y '{variable2}' no son compatibles");
						sinErrores = false;
						return true;
					}
				}
				else
				{
					var entero2Result = enteroList.FirstOrDefault(v => v.nombre == result2.Key);
					var short2Result = shortList.FirstOrDefault(v => v.nombre == result2.Key);
					var long2Result = longList.FirstOrDefault(v => v.nombre == result2.Key);
					var float2Result = floatList.FirstOrDefault(v => v.nombre == result2.Key);
					var double2Result = doubleList.FirstOrDefault(v => v.nombre == result2.Key);
					var boolean2Result = booleanList.FirstOrDefault(v => v.nombre == result2.Key);
					var char2Result = charList.FirstOrDefault(v => v.nombre == result2.Key);
					var cadena2Result = cadenaList.FirstOrDefault(v => v.nombre == result2.Key);

					if (enteroResult is not null && entero2Result is not null)
						enteroResult.valor = entero2Result.valor;

					else if (shortResult is not null && short2Result is not null)
						shortResult.valor = short2Result.valor;

					else if (longResult is not null && long2Result is not null)
						longResult.valor = long2Result.valor;

					else if (floatResult is not null && float2Result is not null)
						floatResult.valor = float2Result.valor;

					else if (doubleResult is not null && double2Result is not null)
						doubleResult.valor = double2Result.valor;

					else if (booleanResult is not null && boolean2Result is not null)
						booleanResult.valor = boolean2Result.valor;

					else if (charResult is not null && char2Result is not null)
					{
						charResult.valor = char2Result.valor;
					}
					else if (cadenaResult is not null && cadena2Result is not null)
					{
						cadenaResult.valor = cadena2Result.valor;
					}

					else
						Imprimir($"\nLos tipos de datos '{variable1}' y '{variable2}' no son compatibles");
				}
			}
		}
		else
			return true;

		return false;
	}

	//Verificar Condicion
	bool VerificarCondicion()
	{
		List<string> nombres = new List<string>();


		////////////////////////////////////////////////////////////////
		int indiceLlave = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, indiceLlave + 2).Trim();
		valor = borrarCadena(borrarLinea);
		borrarLinea = borrarVariablesCadena(borrarLinea, "if(");

		//buscar la primera variable
		int primerEspacio = borrarLinea.IndexOf(' ');
		string variable1 = borrarLinea.Substring(0, primerEspacio).Trim();
		nombres.Add(variable1);

		//borrar primera variable
		borrarLinea = borrarVariablesCadena(borrarLinea, variable1);

		//tomar condicional
		primerEspacio = borrarLinea.IndexOf(' ');
		int segundoEspacio = borrarLinea.LastIndexOf(' ');
		string condicional = borrarLinea.Substring(0, primerEspacio).Trim();

		//buscar la segunda variable
		var borrar = borrarLinea.Substring(0, segundoEspacio);
		borrarLinea = borrarVariablesCadena(borrarLinea, borrar);

		int parentesis = borrarLinea.IndexOf(')');

		string variable2 = borrarLinea.Substring(0, parentesis).Trim();
		nombres.Add(variable2);

		int Index = 0;
		//Enteros
		int condicionalEntero1 = 0;
		int condicionalEntero2 = 0;

		//Shor
		short condicionalShort1 = 0;
		short condicionalShort2 = 0;

		//Long
		long condicionalLong1 = 0;
		long condicionalLong2 = 0;

		//Float
		float condicionalFloat1 = 0f;
		float condicionalFloat2 = 0f;

		//Double
		double condicionalDouble1 = 0d;
		double condicionalDouble2 = 0d;

		foreach (var nombre in nombres)
		{
			if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == nombre);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var booleanResult = booleanList.FirstOrDefault(v => v.nombre == result.Key);
					var charResult = charList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					//var result2 = variables.FirstOrDefault(v => v.Key == variable2);

					if (enteroResult is not null)
					{
						if (Index == 0)
							condicionalEntero1 = enteroResult.valor;

						else
						{
							condicionalEntero2 = enteroResult.valor;
							CondicionesEntero(condicional, condicionalEntero1, condicionalEntero2);
						}
					}

					if (result.Key == null)
					{


						// else if (shortResult is not null && short.TryParse(variable2, out short datoShort))
						// 	shortResult.valor = datoShort;

						// else if (longResult is not null && long.TryParse(variable2, out long datoLong))
						// 	longResult.valor = datoLong;

						// else if (floatResult is not null && float.TryParse(variable2, out float datoFloat))
						// 	floatResult.valor = datoFloat;

						// else if (doubleResult is not null && double.TryParse(variable2, out double datoDouble))
						// 	doubleResult.valor = datoDouble;

						// else if (booleanResult is not null && bool.TryParse(variable2, out bool datoBoolean))
						// 	booleanResult.valor = datoBoolean;

						// else if (charResult is not null)
						// {
						// 	// Si es un char, asegúrate de que el valor tenga comillas simples
						// 	if (variable2.Length != 3 || variable2[0] != '\'' || variable2[2] != '\'')
						// 	{
						// 		Imprimir($"\nSe esperaban comillas simples para el tipo de dato char en la variable '{variable1}'");
						// 		sinErrores = false;
						// 		break;
						// 	}
						// 	charResult.valor = variable2[1]; // Asigna el valor entre las comillas simples
						// }
						// else if (cadenaResult is not null)
						// {
						// 	// Si es un string, asegúrate de que el valor tenga comillas dobles
						// 	if (variable2.Length < 2 || variable2[0] != '"' || variable2[variable2.Length - 1] != '"')
						// 	{
						// 		Imprimir($"\nSe esperaban comillas dobles para el tipo de dato string en la variable '{variable1}'");
						// 		sinErrores = false;
						// 		break;
						// 	}
						// 	cadenaResult.valor = variable2.Substring(1, variable2.Length - 2); // Asigna el valor entre las comillas dobles
						// }

						// else
						// {
						// 	Imprimir($"\nLos tipos de datos '{variable1}' y '{variable2}' no son compatibles");
						// 	sinErrores = false;
						// 	break;
						// }
					}
					// else
					// {
					// 	var entero2Result = enteroList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var short2Result = shortList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var long2Result = longList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var float2Result = floatList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var double2Result = doubleList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var boolean2Result = booleanList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var char2Result = charList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var cadena2Result = cadenaList.FirstOrDefault(v => v.nombre == result2.Key);

					// 	if (enteroResult is not null && entero2Result is not null)
					// 		enteroResult.valor = entero2Result.valor;

					// 	else if (shortResult is not null && short2Result is not null)
					// 		shortResult.valor = short2Result.valor;

					// 	else if (longResult is not null && long2Result is not null)
					// 		longResult.valor = long2Result.valor;

					// 	else if (floatResult is not null && float2Result is not null)
					// 		floatResult.valor = float2Result.valor;

					// 	else if (doubleResult is not null && double2Result is not null)
					// 		doubleResult.valor = double2Result.valor;

					// 	else if (booleanResult is not null && boolean2Result is not null)
					// 		booleanResult.valor = boolean2Result.valor;

					// 	else if (charResult is not null && char2Result is not null)
					// 	{
					// 		charResult.valor = char2Result.valor;
					// 	}
					// 	else if (cadenaResult is not null && cadena2Result is not null)
					// 	{
					// 		cadenaResult.valor = cadena2Result.valor;
					// 	}

					// 	else
					// 		Imprimir($"\nLos tipos de datos '{variable1}' y '{variable2}' no son compatibles");
					// }
				}
				else
				{
					if (int.TryParse(nombre, out int variableEntera))
					{

						if (Index == 0)
							condicionalEntero1 = variableEntera;

						else
						{
							condicionalEntero2 = variableEntera;
							CondicionesEntero(condicional, condicionalEntero1, condicionalEntero2);
						}
					}

					else if (short.TryParse(nombre, out short variableShort))
					{
						if (Index == 0)
							condicionalShort1 = variableShort;

						else
						{
							condicionalShort2 = variableShort;
							CondicionesShort(condicional, condicionalShort1, condicionalShort2);
						}
					}

					else if (long.TryParse(nombre, out long variableLong))
					{
						if (Index == 0)
							condicionalLong1 = variableLong;

						else
						{
							condicionalLong2 = variableLong;
							CondicionesLong(condicional, condicionalLong1, condicionalLong2);
						}
					}

					else if (float.TryParse(nombre, out float variableFloat))
					{
						if (Index == 0)
							condicionalFloat1 = variableFloat;

						else
						{
							condicionalFloat2 = variableFloat;
							CondicionesFloat(condicional, condicionalFloat1, condicionalFloat2);
						}
					}

					else if (double.TryParse(nombre, out double variableDouble))
					{
						if (Index == 0)
							condicionalDouble1 = variableDouble;

						else
						{
							condicionalDouble2 = variableDouble;
							CondicionesDouble(condicional, condicionalDouble1, condicionalDouble2);
						}
					}

					else
					{
						// Imprimir($"\nLos tipos de datos '{variable}' y '{nombre}' no son compatibles");
						// return true;
					}
				}
				Index++;
			}
			else
				break;
		}
		return false;
	}

	void CicloFor()
	{


		string condicion = "<";

		Func<int, int, bool> comparador = null;

		// Definir el comparador basado en la condición
		switch (condicion)
		{
			case "<":
				comparador = (a, b) => a < b;
				break;
			case ">":
				comparador = (a, b) => a > b;
				break;
			// Agrega más condiciones según sea necesario
			default:
				throw new ArgumentException("Condición no válida");
		}

		if (comparador != null)
		{
			for (int i = 0; comparador(i, 5); i++)
			{
				Console.WriteLine(i);
			}
		}
	}

	bool CicloWhile()
	{
		List<string> nombres = new List<string>();


		////////////////////////////////////////////////////////////////
		int indiceLlave = valor.IndexOf('\n');

		var borrarLinea = valor.Substring(0, indiceLlave + 2).Trim();
		valor = borrarCadena(borrarLinea);
		borrarLinea = borrarVariablesCadena(borrarLinea, "while(");

		//buscar la primera variable
		int primerEspacio = borrarLinea.IndexOf(' ');
		string variable1 = borrarLinea.Substring(0, primerEspacio).Trim();
		nombres.Add(variable1);

		//borrar primera variable
		borrarLinea = borrarVariablesCadena(borrarLinea, variable1);

		//tomar condicional
		primerEspacio = borrarLinea.IndexOf(' ');
		int segundoEspacio = borrarLinea.LastIndexOf(' ');
		string condicional = borrarLinea.Substring(0, primerEspacio).Trim();

		//buscar la segunda variable
		var borrar = borrarLinea.Substring(0, segundoEspacio);
		borrarLinea = borrarVariablesCadena(borrarLinea, borrar);

		int parentesis = borrarLinea.IndexOf(')');

		string variable2 = borrarLinea.Substring(0, parentesis).Trim();
		nombres.Add(variable2);

		int Index = 0;
		//Enteros
		int condicionalEntero1 = 0;
		int condicionalEntero2 = 0;

		//Shor
		short condicionalShort1 = 0;
		short condicionalShort2 = 0;

		//Long
		long condicionalLong1 = 0;
		long condicionalLong2 = 0;

		//Float
		float condicionalFloat1 = 0f;
		float condicionalFloat2 = 0f;

		//Double
		double condicionalDouble1 = 0d;
		double condicionalDouble2 = 0d;

		foreach (var nombre in nombres)
		{
			if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == nombre);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var booleanResult = booleanList.FirstOrDefault(v => v.nombre == result.Key);
					var charResult = charList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					//var result2 = variables.FirstOrDefault(v => v.Key == variable2);

					if (enteroResult is not null)
					{
						if (Index == 0)
							condicionalEntero1 = enteroResult.valor;

						else
						{
							condicionalEntero2 = enteroResult.valor;
							ActivarCicloWhileEntero(condicional, condicionalEntero1, condicionalEntero2);
						}
					}

					if (result.Key == null)
					{


						// else if (shortResult is not null && short.TryParse(variable2, out short datoShort))
						// 	shortResult.valor = datoShort;

						// else if (longResult is not null && long.TryParse(variable2, out long datoLong))
						// 	longResult.valor = datoLong;

						// else if (floatResult is not null && float.TryParse(variable2, out float datoFloat))
						// 	floatResult.valor = datoFloat;

						// else if (doubleResult is not null && double.TryParse(variable2, out double datoDouble))
						// 	doubleResult.valor = datoDouble;

						// else if (booleanResult is not null && bool.TryParse(variable2, out bool datoBoolean))
						// 	booleanResult.valor = datoBoolean;

						// else if (charResult is not null)
						// {
						// 	// Si es un char, asegúrate de que el valor tenga comillas simples
						// 	if (variable2.Length != 3 || variable2[0] != '\'' || variable2[2] != '\'')
						// 	{
						// 		Imprimir($"\nSe esperaban comillas simples para el tipo de dato char en la variable '{variable1}'");
						// 		sinErrores = false;
						// 		break;
						// 	}
						// 	charResult.valor = variable2[1]; // Asigna el valor entre las comillas simples
						// }
						// else if (cadenaResult is not null)
						// {
						// 	// Si es un string, asegúrate de que el valor tenga comillas dobles
						// 	if (variable2.Length < 2 || variable2[0] != '"' || variable2[variable2.Length - 1] != '"')
						// 	{
						// 		Imprimir($"\nSe esperaban comillas dobles para el tipo de dato string en la variable '{variable1}'");
						// 		sinErrores = false;
						// 		break;
						// 	}
						// 	cadenaResult.valor = variable2.Substring(1, variable2.Length - 2); // Asigna el valor entre las comillas dobles
						// }

						// else
						// {
						// 	Imprimir($"\nLos tipos de datos '{variable1}' y '{variable2}' no son compatibles");
						// 	sinErrores = false;
						// 	break;
						// }
					}
					// else
					// {
					// 	var entero2Result = enteroList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var short2Result = shortList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var long2Result = longList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var float2Result = floatList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var double2Result = doubleList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var boolean2Result = booleanList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var char2Result = charList.FirstOrDefault(v => v.nombre == result2.Key);
					// 	var cadena2Result = cadenaList.FirstOrDefault(v => v.nombre == result2.Key);

					// 	if (enteroResult is not null && entero2Result is not null)
					// 		enteroResult.valor = entero2Result.valor;

					// 	else if (shortResult is not null && short2Result is not null)
					// 		shortResult.valor = short2Result.valor;

					// 	else if (longResult is not null && long2Result is not null)
					// 		longResult.valor = long2Result.valor;

					// 	else if (floatResult is not null && float2Result is not null)
					// 		floatResult.valor = float2Result.valor;

					// 	else if (doubleResult is not null && double2Result is not null)
					// 		doubleResult.valor = double2Result.valor;

					// 	else if (booleanResult is not null && boolean2Result is not null)
					// 		booleanResult.valor = boolean2Result.valor;

					// 	else if (charResult is not null && char2Result is not null)
					// 	{
					// 		charResult.valor = char2Result.valor;
					// 	}
					// 	else if (cadenaResult is not null && cadena2Result is not null)
					// 	{
					// 		cadenaResult.valor = cadena2Result.valor;
					// 	}

					// 	else
					// 		Imprimir($"\nLos tipos de datos '{variable1}' y '{variable2}' no son compatibles");
					// }
				}
				else
				{
					if (int.TryParse(nombre, out int variableEntera))
					{

						if (Index == 0)
							condicionalEntero1 = variableEntera;

						else
						{
							condicionalEntero2 = variableEntera;
							ActivarCicloWhileEntero(condicional, condicionalEntero1, condicionalEntero2);
						}
					}

					else if (short.TryParse(nombre, out short variableShort))
					{
						if (Index == 0)
							condicionalShort1 = variableShort;

						else
						{
							condicionalShort2 = variableShort;
							CondicionesShort(condicional, condicionalShort1, condicionalShort2);
						}
					}

					else if (long.TryParse(nombre, out long variableLong))
					{
						if (Index == 0)
							condicionalLong1 = variableLong;

						else
						{
							condicionalLong2 = variableLong;
							CondicionesLong(condicional, condicionalLong1, condicionalLong2);
						}
					}

					else if (float.TryParse(nombre, out float variableFloat))
					{
						if (Index == 0)
							condicionalFloat1 = variableFloat;

						else
						{
							condicionalFloat2 = variableFloat;
							CondicionesFloat(condicional, condicionalFloat1, condicionalFloat2);
						}
					}

					else if (double.TryParse(nombre, out double variableDouble))
					{
						if (Index == 0)
							condicionalDouble1 = variableDouble;

						else
						{
							condicionalDouble2 = variableDouble;
							CondicionesDouble(condicional, condicionalDouble1, condicionalDouble2);
						}
					}

					else
					{
						// Imprimir($"\nLos tipos de datos '{variable}' y '{nombre}' no son compatibles");
						// return true;
					}
				}
				Index++;
			}
			else
				break;
		}
		return false;
	}

	void ActivarCicloWhileEntero(string condicional, int entero1, int entero2)
	{
		//Quitar llaves
		// int fin = valor.IndexOf('}');
		// var borrarLinea = valor.Substring(0, fin + 1).Trim();
		// valor = borrarCadena(borrarLinea);

		valor = borrarCadena("{").Trim();
		valor = valor.Remove(valor.Length - 1, 1).Trim();
		var guardar = valor;

		Func<int, int, bool> comparador = ActivarCondicion(condicional);

		while (comparador(entero1, entero2))
		{
			valor = guardar;
			while(valor.Length > 1)
			{
				//Comentario
				if (Regex.IsMatch(valor, patronComentario))
				{
					int indiceSaltoLinea = valor.IndexOf('\n');
					var borrarComentario = valor.Substring(0, indiceSaltoLinea);
					valor = borrarCadena(borrarComentario);
				}

				//Imprimir
				else if (Regex.IsMatch(valor, patronPrint) || Regex.IsMatch(valor, patronPrintln)
					|| Regex.IsMatch(valor, patronPrintConVariable)
						|| Regex.IsMatch(valor, patronPrintlnConVariable))
				{
					if (VerificarImprimir()) break;
				}

				//Declaracion de variables
				else if (valor.StartsWith("var ") || valor.StartsWith("val "))
				{
					if (VerificarCreacionVariables()) break;
				}

				//Sumar
				else if (Regex.IsMatch(valor, patronSumar))
				{
					if (VerificarSuma()) break;
				}

				//Restar
				else if (Regex.IsMatch(valor, patronRestar))
				{
					if (VerificarResta()) break;
				}

				//Multiplicar
				else if (Regex.IsMatch(valor, patronMulti))
				{
					if (VerificarMultiplicacion()) break;
				}

				//Dividir
				else if (Regex.IsMatch(valor, patronDivi))
				{
					if (VerificarDivision()) break;
				}

				//Asignar Variable
				else if (Regex.IsMatch(valor, patronAsignacion))
				{
					if (AsignarValorVariable()) break;
				}

				//Condicion
				else if (Regex.IsMatch(valor, patronCondicion))
				{
					if (VerificarCondicion()) break;
				}

				//Ciclo For
				else if (Regex.IsMatch(valor, patronCicloFor))
				{

				}

				//Ciclo While
				else if (Regex.IsMatch(valor, patronCicloWhile))
				{

				}

				else if (Regex.IsMatch(valor, patronContador))
				{
					int indiceMas = valor.LastIndexOf('+');

					var borrarLinea = valor.Substring(0, indiceMas + 1);
					valor = borrarCadena(borrarLinea);

					var indice = borrarLinea.LastIndexOf('+');
					var nombre = borrarLinea.Substring(0, indice - 1);

					if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
					{
						var result = variables.FirstOrDefault(v => v.Key == nombre);
						if (result.Key != null)
						{
							var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);

							if (enteroResult is not null)
							{
								enteroResult.valor += 1;
								entero1 = enteroResult.valor;
							}
							else
							{
								//poner aqui el else
							}
						}
					}
					else
						break;
				}

				else
				{
					sinErrores = false;
					Imprimir($"\n*No se reconoce  \"{valor}\"");
					break;
				}
			}
		}
		// var borrar2 = valor + borrarLinea;
		// valor = borrar2;
	}

	Func<int,int,bool> ActivarCondicion(string condicion)
	{
		Func<int, int, bool> comparador = null;

		// Definir el comparador basado en la condición
		switch (condicion)
		{
			case "==":
				comparador = (a, b) => a == b;
				break;
			case "!=":
				comparador = (a, b) => a != b;
				break;
			case "<":
				comparador = (a, b) => a < b;
				break;
			case "<=":
				comparador = (a, b) => a <= b;
				break;
			case ">":
				comparador = (a, b) => a > b;
				break;
			case ">=":
				comparador = (a, b) => a >= b;
				break;
			default:
				throw new ArgumentException("Condición no válida");
		}

		return comparador;
	}

	//condicion en caso de que me falle al buscar el indice

	// 	if (indiceComillasInicio != -1 && indiceComillasFin != -1 && indiceComillasInicio<indiceComillasFin)
	// {

	// }

	//Comparar Enteros
	void CondicionesEntero(string condicional, int condicional1, int condicional2)
	{
		bool resultado = CompararEnteros(condicional, condicional1, condicional2);
		ManejarResultado(resultado);
	}

	bool CompararEnteros(string condicional, int condicional1, int condicional2)
	{
		switch (condicional)
		{
			case "==":
				return condicional1 == condicional2;
			case "!=":
				return condicional1 != condicional2;
			case "<":
				return condicional1 < condicional2;
			case "<=":
				return condicional1 <= condicional2;
			case ">":
				return condicional1 > condicional2;
			case ">=":
				return condicional1 >= condicional2;
			default:
				throw new ArgumentException("Condicional no válido");
		}
	}

	//Comparar Shorts
	void CondicionesShort(string condicional, short condicional1, short condicional2)
	{
		bool resultado = CompararShort(condicional, condicional1, condicional2);
		ManejarResultado(resultado);
	}

	bool CompararShort(string condicional, short condicional1, short condicional2)
	{
		switch (condicional)
		{
			case "==":
				return condicional1 == condicional2;
			case "!=":
				return condicional1 != condicional2;
			case "<":
				return condicional1 < condicional2;
			case "<=":
				return condicional1 <= condicional2;
			case ">":
				return condicional1 > condicional2;
			case ">=":
				return condicional1 >= condicional2;
			default:
				throw new ArgumentException("Condicional no válido");
		}
	}

	//Comparar Longs
	void CondicionesLong(string condicional, long condicional1, long condicional2)
	{
		bool resultado = CompararLong(condicional, condicional1, condicional2);
		ManejarResultado(resultado);
	}

	bool CompararLong(string condicional, long condicional1, long condicional2)
	{
		switch (condicional)
		{
			case "==":
				return condicional1 == condicional2;
			case "!=":
				return condicional1 != condicional2;
			case "<":
				return condicional1 < condicional2;
			case "<=":
				return condicional1 <= condicional2;
			case ">":
				return condicional1 > condicional2;
			case ">=":
				return condicional1 >= condicional2;
			default:
				throw new ArgumentException("Condicional no válido");
		}
	}

	//Comparar Floats
	void CondicionesFloat(string condicional, float condicional1, float condicional2)
	{
		bool resultado = CompararFloat(condicional, condicional1, condicional2);
		ManejarResultado(resultado);
	}

	bool CompararFloat(string condicional, float condicional1, float condicional2)
	{
		switch (condicional)
		{
			case "==":
				return condicional1 == condicional2;
			case "!=":
				return condicional1 != condicional2;
			case "<":
				return condicional1 < condicional2;
			case "<=":
				return condicional1 <= condicional2;
			case ">":
				return condicional1 > condicional2;
			case ">=":
				return condicional1 >= condicional2;
			default:
				throw new ArgumentException("Condicional no válido");
		}
	}

	//Comparar Doubles
	void CondicionesDouble(string condicional, double condicional1, double condicional2)
	{
		bool resultado = CompararDouble(condicional, condicional1, condicional2);
		ManejarResultado(resultado);
	}

	bool CompararDouble(string condicional, double condicional1, double condicional2)
	{
		switch (condicional)
		{
			case "==":
				return condicional1 == condicional2;
			case "!=":
				return condicional1 != condicional2;
			case "<":
				return condicional1 < condicional2;
			case "<=":
				return condicional1 <= condicional2;
			case ">":
				return condicional1 > condicional2;
			case ">=":
				return condicional1 >= condicional2;
			default:
				throw new ArgumentException("Condicional no válido");
		}
	}

	void ManejarResultado(bool resultado)
	{
		int indiceLLave = valor.IndexOf('}');
		var borrarLinea = valor.Substring(0, indiceLLave + 1).Trim();

		if (resultado)
		{
			var guardarTrue = borrarLinea;
			valor = borrarCadena(borrarLinea);
			borrarLinea = borrarLinea.Substring(1).Trim();
			borrarLinea = borrarLinea.Remove(borrarLinea.Length - 1, 1).Trim();

			if (Regex.IsMatch(valor, patronElse))
			{
				valor = borrarCadena("else").Trim();

				int indiceElse = valor.IndexOf('}');
				borrarLinea = valor.Substring(0, indiceElse + 1).Trim();
				valor = borrarCadena(borrarLinea);
				guardarTrue = borrarVariablesCadena(guardarTrue, "{");
				guardarTrue = guardarTrue.Remove(guardarTrue.Length - 1, 1);

				var indexar = guardarTrue + valor;
				valor = indexar.Trim();
			}
			else
			{
				var borrar2 = valor + borrarLinea;
				valor = borrar2;
			}
		}
		else
		{
			valor = borrarCadena(borrarLinea);

			if (Regex.IsMatch(valor, patronElse))
			{
				valor = borrarCadena("else").Trim();

				int indiceElse = valor.IndexOf('}');
				borrarLinea = valor.Substring(0, indiceElse + 1).Trim();
				valor = borrarCadena(borrarLinea);
				borrarLinea = borrarVariablesCadena(borrarLinea, "{");
				borrarLinea = borrarLinea.Remove(borrarLinea.Length - 1, 1).Trim();

				var indexar = borrarLinea + valor;
				valor = indexar;
			}
		}
	}



	//Operaciones aritmeticas
	bool Sumar(string dato)
	{
		List<string> nombres = new List<string>();
		int sumEntero = 0;
		short sumShort = 0;
		long sumLong = 0;
		float sumFloat = 0;
		double sumDouble = 0;

		//utilizar un ciclo para que me busque las variables
		int indiceIgual = dato.IndexOf('=');

		string variable = dato.Substring(0, indiceIgual).Trim();
		nombres.Add(variable);

		var borrarLinea = dato.Substring(0, indiceIgual + 1);
		//valor = borrarCadena(borrarLinea);
		dato = borrarVariablesCadena(dato,borrarLinea);
		string dato1;

		while(dato.Length > 1)
		{
			int indiceMas = dato.IndexOf('+');

			if(indiceMas != -1)
			{
				dato1 = dato.Substring(0, indiceMas).Trim();
				borrarLinea = dato.Substring(0, indiceMas + 1);
			}
			else
			{
				int indiceSaltoLinea = dato.IndexOf('\n');
				dato1 = dato.Substring(0, indiceSaltoLinea).Trim();
				borrarLinea = dato.Substring(0, indiceSaltoLinea + 1);
			}
			nombres.Add(dato1);
			dato = borrarVariablesCadena(dato, borrarLinea);
		}

		//contador
		int Index = 0;

		foreach(var nombre in nombres)
		{
			if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == nombre);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					if (enteroResult is not null)
					{
						if (Index == 1)
							sumEntero = enteroResult.valor;

						else if (Index > 1)
							sumEntero += enteroResult.valor;
					}

					else if (shortResult is not null)
					{
						if(Index == 1)
							sumShort = shortResult.valor;

						else if(Index > 1)
							sumShort += shortResult.valor;
					}

					else if (longResult is not null)
					{
						if(Index == 1)
							sumLong = longResult.valor;

						else if(Index > 1)
							sumLong += longResult.valor;
					}

					else if (floatResult is not null)
					{
						if(Index == 1)
							sumFloat = floatResult.valor;

						else if(Index > 1)
							sumFloat += floatResult.valor;
					}

					else if (doubleResult is not null)
					{
						if(Index == 1)
							sumDouble = doubleResult.valor;

						else if(Index > 1)
							sumDouble += doubleResult.valor;
					}
				}
				else
				{

					if (int.TryParse(nombre, out int variableEntera))
					{
						if(Index == 1)
							sumEntero = variableEntera;

						else if(Index > 1)
							sumEntero += variableEntera;
					}

					else if (short.TryParse(nombre, out short variableShort))
					{
						if(Index == 1)
							sumShort = variableShort;

						else if(Index > 1)
							sumShort += variableShort;
					}

					else if (long.TryParse(nombre, out long variableLong))
					{
						if(Index == 1)
							sumLong = variableLong;

						else if(Index > 1)
							sumLong += variableLong;
					}

					else if (float.TryParse(nombre, out float variableFloat))
					{
						if(Index == 1)
							sumFloat = variableFloat;

						else if(Index > 1)
							sumFloat += variableFloat;
					}

					else if (double.TryParse(nombre, out double variableDouble))
					{
						if(Index == 1)
							sumDouble = variableDouble;

						else if(Index > 1)
							sumDouble += variableDouble;
					}

					else
					{
						Imprimir($"\nLos tipos de datos '{variable}' y '{nombre}' no son compatibles");
						return true;
					}
				}
				Index++;
			}
			else
				break;
		}

		//asignar valor a variable
		var resul = variables.FirstOrDefault(v => v.Key == variable);
		if (resul.Key != null)
		{
			var enteroResult = enteroList.FirstOrDefault(v => v.nombre == resul.Key);
			var shortResult = shortList.FirstOrDefault(v => v.nombre == resul.Key);
			var longResult = longList.FirstOrDefault(v => v.nombre == resul.Key);
			var floatResult = floatList.FirstOrDefault(v => v.nombre == resul.Key);
			var doubleResult = doubleList.FirstOrDefault(v => v.nombre == resul.Key);
			var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == resul.Key);

			if (enteroResult is not null)
				enteroResult.valor = sumEntero;

			else if (shortResult is not null)
				shortResult.valor = sumShort;

			else if (longResult is not null)
				longResult.valor = sumLong;

			else if (floatResult is not null)
				floatResult.valor = sumFloat;

			else if (doubleResult is not null)
				doubleResult.valor = sumDouble;
		}

		return false;
	}

	bool Restar(string dato)
	{
		List<string> nombres = new List<string>();
		int resEntero = 0;
		short resShort = 0;
		long resLong = 0;
		float resFloat = 0;
		double resDouble = 0;

		//utilizar un ciclo para que me busque las variables
		int indiceIgual = dato.IndexOf('=');

		string variable = dato.Substring(0, indiceIgual).Trim();
		nombres.Add(variable);

		var borrarLinea = dato.Substring(0, indiceIgual + 1);
		//valor = borrarCadena(borrarLinea);
		dato = borrarVariablesCadena(dato, borrarLinea);
		string dato1;

		while (dato.Length > 1)
		{
			int indiceMenos = dato.IndexOf('-');

			if (indiceMenos != -1)
			{
				dato1 = dato.Substring(0, indiceMenos).Trim();
				borrarLinea = dato.Substring(0, indiceMenos + 1);
			}
			else
			{
				int indiceSaltoLinea = dato.IndexOf('\n');
				dato1 = dato.Substring(0, indiceSaltoLinea).Trim();
				borrarLinea = dato.Substring(0, indiceSaltoLinea + 1);
			}
			nombres.Add(dato1);
			dato = borrarVariablesCadena(dato, borrarLinea);
		}

		//contador
		int Index = 0;

		foreach (var nombre in nombres)
		{
			if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == nombre);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					if (enteroResult is not null)
					{
						if (Index == 1)
							resEntero = enteroResult.valor;

						else if (Index > 1)
							resEntero -= enteroResult.valor;
					}

					else if (shortResult is not null)
					{
						if (Index == 1)
							resShort = shortResult.valor;

						else if (Index > 1)
							resShort -= shortResult.valor;
					}

					else if (longResult is not null)
					{
						if (Index == 1)
							resLong = longResult.valor;

						else if (Index > 1)
							resLong -= longResult.valor;
					}

					else if (floatResult is not null)
					{
						if (Index == 1)
							resFloat = floatResult.valor;

						else if (Index > 1)
							resFloat -= floatResult.valor;
					}

					else if (doubleResult is not null)
					{
						if (Index == 1)
							resDouble = doubleResult.valor;

						else if (Index > 1)
							resDouble -= doubleResult.valor;
					}
				}
				else
				{

					if (int.TryParse(nombre, out int variableEntera))
					{
						if (Index == 1)
							resEntero = variableEntera;

						else if (Index > 1)
							resEntero -= variableEntera;
					}

					else if (short.TryParse(nombre, out short variableShort))
					{
						if (Index == 1)
							resShort = variableShort;

						else if (Index > 1)
							resShort -= variableShort;
					}

					else if (long.TryParse(nombre, out long variableLong))
					{
						if (Index == 1)
							resLong = variableLong;

						else if (Index > 1)
							resLong -= variableLong;
					}

					else if (float.TryParse(nombre, out float variableFloat))
					{
						if (Index == 1)
							resFloat = variableFloat;

						else if (Index > 1)
							resFloat -= variableFloat;
					}

					else if (double.TryParse(nombre, out double variableDouble))
					{
						if (Index == 1)
							resDouble = variableDouble;

						else if (Index > 1)
							resDouble -= variableDouble;
					}

					else
					{
						Imprimir($"\nLos tipos de datos '{variable}' y '{nombre}' no son compatibles");
						return true;
					}
				}
				Index++;
			}
			else
				break;
		}

		//asignar valor a variable
		var resul = variables.FirstOrDefault(v => v.Key == variable);
		if (resul.Key != null)
		{
			var enteroResult = enteroList.FirstOrDefault(v => v.nombre == resul.Key);
			var shortResult = shortList.FirstOrDefault(v => v.nombre == resul.Key);
			var longResult = longList.FirstOrDefault(v => v.nombre == resul.Key);
			var floatResult = floatList.FirstOrDefault(v => v.nombre == resul.Key);
			var doubleResult = doubleList.FirstOrDefault(v => v.nombre == resul.Key);
			var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == resul.Key);

			if (enteroResult is not null)
				enteroResult.valor = resEntero;

			else if (shortResult is not null)
				shortResult.valor = resShort;

			else if (longResult is not null)
				longResult.valor = resLong;

			else if (floatResult is not null)
				floatResult.valor = resFloat;

			else if (doubleResult is not null)
				doubleResult.valor = resDouble;
		}

		return false;
	}

	bool Multiplicar(string dato)
	{
		List<string> nombres = new List<string>();
		int multiEntero = 0;
		short multiShort = 0;
		long multiLong = 0;
		float multiFloat = 0;
		double multiDouble = 0;

		//utilizar un ciclo para que me busque las variables
		int indiceIgual = dato.IndexOf('=');

		string variable = dato.Substring(0, indiceIgual).Trim();
		nombres.Add(variable);

		var borrarLinea = dato.Substring(0, indiceIgual + 1);
		//valor = borrarCadena(borrarLinea);
		dato = borrarVariablesCadena(dato, borrarLinea);
		string dato1;

		while (dato.Length > 1)
		{
			int indiceMulti = dato.IndexOf('*');

			if (indiceMulti != -1)
			{
				dato1 = dato.Substring(0, indiceMulti).Trim();
				borrarLinea = dato.Substring(0, indiceMulti + 1);
			}
			else
			{
				int indiceSaltoLinea = dato.IndexOf('\n');
				dato1 = dato.Substring(0, indiceSaltoLinea).Trim();
				borrarLinea = dato.Substring(0, indiceSaltoLinea + 1);
			}
			nombres.Add(dato1);
			dato = borrarVariablesCadena(dato, borrarLinea);
		}

		//contador
		int Index = 0;

		foreach (var nombre in nombres)
		{
			if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == nombre);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					if (enteroResult is not null)
					{
						if (Index == 1)
							multiEntero = enteroResult.valor;

						else if (Index > 1)
							multiEntero *= enteroResult.valor;
					}

					else if (shortResult is not null)
					{
						if (Index == 1)
							multiShort = shortResult.valor;

						else if (Index > 1)
							multiShort *= shortResult.valor;
					}

					else if (longResult is not null)
					{
						if (Index == 1)
							multiLong = longResult.valor;

						else if (Index > 1)
							multiLong *= longResult.valor;
					}

					else if (floatResult is not null)
					{
						if (Index == 1)
							multiFloat = floatResult.valor;

						else if (Index > 1)
							multiFloat *= floatResult.valor;
					}

					else if (doubleResult is not null)
					{
						if (Index == 1)
							multiDouble = doubleResult.valor;

						else if (Index > 1)
							multiDouble *= doubleResult.valor;
					}
				}
				else
				{

					if (int.TryParse(nombre, out int variableEntera))
					{
						if (Index == 1)
							multiEntero = variableEntera;

						else if (Index > 1)
							multiEntero *= variableEntera;
					}

					else if (short.TryParse(nombre, out short variableShort))
					{
						if (Index == 1)
							multiShort = variableShort;

						else if (Index > 1)
							multiShort *= variableShort;
					}

					else if (long.TryParse(nombre, out long variableLong))
					{
						if (Index == 1)
							multiLong = variableLong;

						else if (Index > 1)
							multiLong *= variableLong;
					}

					else if (float.TryParse(nombre, out float variableFloat))
					{
						if (Index == 1)
							multiFloat = variableFloat;

						else if (Index > 1)
							multiFloat *= variableFloat;
					}

					else if (double.TryParse(nombre, out double variableDouble))
					{
						if (Index == 1)
							multiDouble = variableDouble;

						else if (Index > 1)
							multiDouble *= variableDouble;
					}

					else
					{
						Imprimir($"\nLos tipos de datos '{variable}' y '{nombre}' no son compatibles");
						return true;
					}
				}
				Index++;
			}
			else
				break;
		}

		//asignar valor a variable
		var resul = variables.FirstOrDefault(v => v.Key == variable);
		if (resul.Key != null)
		{
			var enteroResult = enteroList.FirstOrDefault(v => v.nombre == resul.Key);
			var shortResult = shortList.FirstOrDefault(v => v.nombre == resul.Key);
			var longResult = longList.FirstOrDefault(v => v.nombre == resul.Key);
			var floatResult = floatList.FirstOrDefault(v => v.nombre == resul.Key);
			var doubleResult = doubleList.FirstOrDefault(v => v.nombre == resul.Key);
			var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == resul.Key);

			if (enteroResult is not null)
				enteroResult.valor = multiEntero;

			else if (shortResult is not null)
				shortResult.valor = multiShort;

			else if (longResult is not null)
				longResult.valor = multiLong;

			else if (floatResult is not null)
				floatResult.valor = multiFloat;

			else if (doubleResult is not null)
				doubleResult.valor = multiDouble;
		}

		return false;
	}

	bool Dividir(string dato)
	{
		List<string> nombres = new List<string>();
		int diviEntero = 0;
		short diviShort = 0;
		long diviLong = 0;
		float diviFloat = 0;
		double diviDouble = 0;

		//utilizar un ciclo para que me busque las variables
		int indiceIgual = dato.IndexOf('=');

		string variable = dato.Substring(0, indiceIgual).Trim();
		nombres.Add(variable);

		var borrarLinea = dato.Substring(0, indiceIgual + 1);
		//valor = borrarCadena(borrarLinea);
		dato = borrarVariablesCadena(dato, borrarLinea);
		string dato1;

		while (dato.Length > 1)
		{
			int indiceDivi = dato.IndexOf('/');

			if (indiceDivi != -1)
			{
				dato1 = dato.Substring(0, indiceDivi).Trim();
				borrarLinea = dato.Substring(0, indiceDivi + 1);
			}
			else
			{
				int indiceSaltoLinea = dato.IndexOf('\n');
				dato1 = dato.Substring(0, indiceSaltoLinea).Trim();
				borrarLinea = dato.Substring(0, indiceSaltoLinea + 1);
			}
			nombres.Add(dato1);
			dato = borrarVariablesCadena(dato, borrarLinea);
		}

		//contador
		int Index = 0;

		foreach (var nombre in nombres)
		{
			if (VerificarQueNoSeaUnaPalabraReservada(nombre) == false)
			{
				var result = variables.FirstOrDefault(v => v.Key == nombre);
				if (result.Key != null)
				{
					var enteroResult = enteroList.FirstOrDefault(v => v.nombre == result.Key);
					var shortResult = shortList.FirstOrDefault(v => v.nombre == result.Key);
					var longResult = longList.FirstOrDefault(v => v.nombre == result.Key);
					var floatResult = floatList.FirstOrDefault(v => v.nombre == result.Key);
					var doubleResult = doubleList.FirstOrDefault(v => v.nombre == result.Key);
					var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == result.Key);

					if (enteroResult is not null)
					{
						if (Index == 1)
							diviEntero = enteroResult.valor;

						else if (Index > 1)
							diviEntero /= enteroResult.valor;
					}

					else if (shortResult is not null)
					{
						if (Index == 1)
							diviShort = shortResult.valor;

						else if (Index > 1)
							diviShort /= shortResult.valor;
					}

					else if (longResult is not null)
					{
						if (Index == 1)
							diviLong = longResult.valor;

						else if (Index > 1)
							diviLong /= longResult.valor;
					}

					else if (floatResult is not null)
					{
						if (Index == 1)
							diviFloat = floatResult.valor;

						else if (Index > 1)
							diviFloat /= floatResult.valor;
					}

					else if (doubleResult is not null)
					{
						if (Index == 1)
							diviDouble = doubleResult.valor;

						else if (Index > 1)
							diviDouble /= doubleResult.valor;
					}
				}
				else
				{

					if (int.TryParse(nombre, out int variableEntera))
					{
						if (Index == 1)
							diviEntero = variableEntera;

						else if (Index > 1)
							diviEntero /= variableEntera;
					}

					else if (short.TryParse(nombre, out short variableShort))
					{
						if (Index == 1)
							diviShort = variableShort;

						else if (Index > 1)
							diviShort /= variableShort;
					}

					else if (long.TryParse(nombre, out long variableLong))
					{
						if (Index == 1)
							diviLong = variableLong;

						else if (Index > 1)
							diviLong /= variableLong;
					}

					else if (float.TryParse(nombre, out float variableFloat))
					{
						if (Index == 1)
							diviFloat = variableFloat;

						else if (Index > 1)
							diviFloat /= variableFloat;
					}

					else if (double.TryParse(nombre, out double variableDouble))
					{
						if (Index == 1)
							diviDouble = variableDouble;

						else if (Index > 1)
							diviDouble /= variableDouble;
					}

					else
					{
						Imprimir($"\nLos tipos de datos '{variable}' y '{nombre}' no son compatibles");
						return true;
					}
				}
				Index++;
			}
			else
				break;
		}

		//asignar valor a variable
		var resul = variables.FirstOrDefault(v => v.Key == variable);
		if (resul.Key != null)
		{
			var enteroResult = enteroList.FirstOrDefault(v => v.nombre == resul.Key);
			var shortResult = shortList.FirstOrDefault(v => v.nombre == resul.Key);
			var longResult = longList.FirstOrDefault(v => v.nombre == resul.Key);
			var floatResult = floatList.FirstOrDefault(v => v.nombre == resul.Key);
			var doubleResult = doubleList.FirstOrDefault(v => v.nombre == resul.Key);
			var cadenaResult = cadenaList.FirstOrDefault(v => v.nombre == resul.Key);

			if (enteroResult is not null)
				enteroResult.valor = diviEntero;

			else if (shortResult is not null)
				shortResult.valor = diviShort;

			else if (longResult is not null)
				longResult.valor = diviLong;

			else if (floatResult is not null)
				floatResult.valor = diviFloat;

			else if (doubleResult is not null)
				doubleResult.valor = diviDouble;
		}

		return false;
	}

	bool VerificarQueNoSeaUnaPalabraReservada(string nombre)
	{
		foreach (var tipo in new[] {
		"Int", "Short", "Byte", "Long", "Float", "Double", "Boolean", "Char", "String", "var", "val", "main", "fun",
		"const", "object", "companion", "private", "public", "protected", "internal", "null", "if", "else", "when", "for",
		"array", "ranges", "list", "while", "do", "false", "true", "constructor", "init", "typealias", "interface", "override",
		"abstract", "class", "super", "data", "enum",
		"as", "as?", "break", "class", "continue", "do", "else", "false", "for", "fun", "if", "in", "!in", "interface", "is",
		"!is", "null", "object", "package", "return", "super", "this", "throw", "true", "try", "typealias", "val", "var", "when",
		"while", "by", "catch", "constructor", "delegate", "dynamic", "field", "file", "finally", "get", "import", "init",
		"param", "property", "receiver", "set", "setparam", "where", "actual", "abstract", "annotation", "companion", "const",
		"crossinline", "data", "enum", "expect", "external", "final", "infix", "inline", "inner", "internal", "lateinit",
		"noinline", "open", "operator", "out", "override", "private", "protected", "public", "reified", "sealed", "suspend",
		"tailrec", "vararg", "field", "it", "value"
		})

		{
			if (nombre == tipo)
			{
				Imprimir($"\n\"{nombre}\" es una palabra reservada");
				sinErrores = false;
				return true;
			}
		}
		return false;
	}


	bool variableExiste(string nombre)
	{
		return variables.ContainsKey(nombre);
	}

	void verTipoDeDato()
	{
		
		
		if (Regex.IsMatch(valor, patronEnteroVal))
		{

		}
	}

	string borrarCadena(string borrar)
	{
		return valor.Substring(borrar.Length).TrimStart();
	}

	string borrarVariablesCadena(string cadena, string borrar)
	{
		return cadena.Substring(borrar.Length).TrimStart();
	}

	void Imprimir(string valor)
	{
		mostrar += valor;
	}
}
